---
title: 'Derri√®re le block()'
date: JUN 1, 2023
description: Alors, comment fonctionne r√©ellement block() avec React ?
---

import Image from 'next/image';
import { Steps, Callout } from 'nextra-theme-docs';
import { CarbonAds } from '../../components/ad';

<div className="flex justify-center">
  <Image src="/behind-the-block.png" width={350} height={130} />
</div>

<div className="flex flex-col items-center gap-4">

# Derri√®re le `block(){:jsx}`

  <small>[AIDEN BAI](https://aidenybai.com) JUN 1 2023</small>
</div>

---

Si vous utilisez Million.js depuis un certain temps, vous avez probablement entendu parler de la fonction [`block(){:jsx}`](/docs/quickstart).

```jsx
function MyComponent() {
  // ...
}

const MyBlock = block(MyComponent);

export default function App() {
  return <MyBlock />; // ‚ú® √ßa fonctionne ! ‚ú®
}
```

Envelopper un composant React avec `block(){:jsx}` cr√©e un bloc. Un bloc est un [**Composant d'Ordre Sup√©rieur (HOC)**](https://legacy.reactjs.org/docs/higher-order-components.html) sp√©cial qui peut √™tre utilis√© comme un composant React, mais qui est hyper-optimis√© pour la vitesse de rendu en utilisant Million.js.

Mais comment est-ce possible ? Comment pouvons-nous utiliser des blocs √† l'int√©rieur de React ? Million.js n'est-il pas un DOM virtuel compl√®tement diff√©rent ?

<CarbonAds />

## Anatomie de `block(){:jsx}`

Une fois que vous avez cr√©√© un bloc et l'utilisez comme un composant React, les √©tapes suivantes se produiront lors du rendu :

![React to Million mount](/react-to-million.png)

<Steps>

### React rend le composant `<Loader />{:jsx}`

Initialement, React est charg√© de rendre le composant `<Loader />{:jsx}`. Ce processus implique la cr√©ation des √©l√©ments DOM n√©cessaires et l'application de toutes les propri√©t√©s ou styles initiaux. Pendant cette phase, React g√®re le cycle de vie et l'√©tat du composant, permettant des fonctionnalit√©s avanc√©es telles que la gestion de l'√©tat, les m√©thodes de cycle de vie, et plus encore.

### React monte `<Loader />{:jsx}` et place l'√©l√©ment DOM dans la r√©f√©rence (ref)

Apr√®s le processus de rendu, React monte ensuite le composant `<Loader />{:jsx}`. Cela implique d'ins√©rer le composant dans le DOM et le rendre visible pour l'utilisateur. √Ä ce stade, React met √©galement √† jour la r√©f√©rence (ref) avec l'√©l√©ment DOM. Une r√©f√©rence (ref) en React est une mani√®re de stocker un √©tat local qui n'entra√Æne pas de rendu, et dans ce cas, elle est utilis√©e pour conserver une r√©f√©rence √† l'√©l√©ment DOM.

### Million.js rend `<App />{:jsx}` dans la r√©f√©rence (ref)

Enfin, la r√©f√©rence (ref) est remise √† Million.js, un DOM virtuel rapide et l√©ger. En utilisant la r√©f√©rence (ref) stock√©e qui pointe vers l'√©l√©ment DOM, Million.js rend directement le composant `<App />{:jsx}` dans cet √©l√©ment. Cela permet √† Million.js de g√©rer le composant `<App />{:jsx}` de mani√®re ind√©pendante de React, entra√Ænant des avantages potentiels en termes de performances et d'isolation des responsabilit√©s.

</Steps>

Ce pattern nous permet de "contr√¥ler" l'√©l√©ment DOM sans que React ne le sache. React ne conna√Ætra que le composant `<Loader />{:jsx}`, et Million.js ne conna√Ætra que le composant `<App />{:jsx}`.

## Mise en ≈ìuvre de `block(){:jsx}`

En gardant cela √† l'esprit, nous pouvons cr√©er une impl√©mentation de base de ce mod√®le.

<Callout type="info">
  Remarque : il ne s'agit pas de la mise en ≈ìuvre proprement dite, mais plut√¥t
  d'un exemple de code conceptuel. exemple. [Voir la source
  ici](https://github.com/aidenybai/million/blob/674b13047665009f8ab1281e77a00a017ddea6e9/packages/react/block.ts#L45)
</Callout>

<Steps>

### Cr√©ation d'une fabrique HOC

Une fabrique HOC consomme un composant React et retourne notre composant `<Loader />{:jsx}`. Le composant `<Loader />{:jsx}` est responsable du rendu de l'√©l√©ment DOM et de sa transmission √† Million.js.

```jsx
const block = (ReactComponent) => {
  return function Loader(props) {
    return /*... */;
  };
};
```

### R√©cup√©ration de l'√©l√©ment DOM avec `useRef(){:js}`

Nous pouvons utiliser le crochet `useRef(){:js}` pour r√©cup√©rer l'√©l√©ment DOM.

```jsx
const block = (ReactComponent) => {
  return function Loader(props) {
    const el = useRef(); // stocke l'√©l√©ment DOM

    return <div ref={el}></div>;
  };
};
```

### Cr√©er un effet pour rendre Million.js

Maintenant, nous mettons tout en place. Nous cr√©ons un composant `<Effect />{:jsx}` qui ex√©cute un effet lors du montage. Cet effet est responsable du rendu du composant `<App />{:jsx}` dans l'√©l√©ment DOM. Nous utilisons `useCallback(){:js}` pour cr√©er une r√©f√©rence de fermeture stable pour l'effet.

Remarquez qu'il y a des appels `Million.convert(){:js}` et `Million.render(){:js}`. Ce ne sont pas de vrais appels, mais ils cr√©ent essentiellement des blocs et les rendent dans l'√©l√©ment DOM.

```jsx
const block = (ReactComponent) => {
  const MillionComponent = Million.convert(ReactComponent);

  return function Loader(props) {
    const el = useRef();

    // 3. Million.js rend <App /> dans la r√©f√©rence
    const effect = useCallback(() => {
      // useCallback est utilis√© comme une r√©f√©rence stable pour la fermeture
      Million.render(MillionComponent, el.current);
    }, []);

    // 2. React monte <Loader /> et place l'√©l√©ment DOM dans la r√©f√©rence
    return (
      <>
        <div ref={el}></div>
        <Effect effect={effect} />
      </>
    );
  };
};

// Effect est un composant qui ex√©cute un effet √† la cr√©ation
function Effect({ effect }) {
  useEffect(effect, []);
  return null;
}
```

</Steps>

## Compilateur, tu es un sorcier ! üßô

Une limitation majeure de l'impl√©mentation en cours d'ex√©cution est qu'elle exige que l'utilisateur passe une composante sans √©tat. Cela est d√ª aux nombreuses limitations de l'impl√©mentation interne du bloc ([voir ici](/docs/block)). Cependant, nous pouvons contourner cette limitation en utilisant le compilateur.

Supposons que nous ayons un composant `<Emotion />{:jsx}` qui a un √©tat `isSad`, et en fonction de cet √©tat, il rend un emoji üò¢ ou üòÇ.

```jsx
function Emotion() {
  const [isSad, setIsSad] = useState(true);
  return <div>{isSad ? 'üò¢' : 'üòÇ'}</div>;
}

const EmotionBlock = block(Emotion);
```

Le compilateur peut extraire l'√©tat `isSad` et le convertir en une prop que Million.js peut comprendre.

```jsx
function Emotion_jsx({ _0 }) {
  return <div>{_0}</div>;
}

const Emotion_jsx_block = block(Emotion_component);

function EmotionBlock() {
  const [isSad, setIsSad] = useState(true);
  return <Emotion_jsx_block _0={isSad ? 'üò¢' : 'üòÇ'} />;
}
```

Mais que se passe-t-il si nous avons un autre composant React √† l'int√©rieur de `<Emotion />{:jsx}` ?

```jsx
function SadEmoji() {
  return 'üò¢';
}

function HappyEmoji() {
  return 'üòÇ';
}

function Emotion() {
  const [isSad, setIsSad] = useState(true);
  return <div>{isSad ? <SadEmoji /> : <HappyEmoji />}</div>;
}

const EmotionBlock = block(Emotion);
```

De m√™me, cela est extrait, mais lors du rendu, lorsqu'il atteint une limite de composant, il cr√©era un "scope de rendu React". Essentiellement, il d√©l√®gue la responsabilit√© du rendu du composant √† React.

```jsx
function SadEmoji() {
  return 'üò¢';
}

function HappyEmoji() {
  return 'üòÇ';
}

function Emotion_jsx({ _0 }) {
  return <div>{_0}</div>;
}

const Emotion_jsx_block = block(Emotion_component);

function EmotionBlock() {
  const [isSad, setIsSad] = useState(true);
  return (
    <Emotion_jsx_block
      _0={renderReactScope(isSad ? <SadEmoji /> : <HappyEmoji />)}
    />
  );
}
```

Comme vous pouvez le voir, le compilateur est capable d'extraire l'√©tat et de le rendre √† partir d'un √©l√©ment parent. Il peut √©galement reconna√Ætre lorsqu'il atteint une limite de composant et d√©l√©guer la responsabilit√© du rendu √† React.

## Pas seulement Million.js

Bien que cet article d√©taille comment Million.js tire parti de ce motif, il n'est pas limit√© √† Million.js.

Pour n'importe quel framework moderne capable de rendre dans un √©l√©ment DOM, vous pouvez utiliser le motif `<Loader />{:jsx}` et le mod√®le HOC pour rendre des composants d'un autre framework √† l'int√©rieur de React.

Un concept tr√®s similaire est l'["architecture des √Æles"](https://www.patterns.dev/posts/islands-architecture), qui vous permet d'encapsuler n'importe quel framework dans du HTML statique. C'est un peu diff√©rent, au lieu de rendre dans du HTML statique, il rend dans un arbre React.

<div className="flex justify-center">
  <Image src="/foreign-tree.png" width={350} height={500} />
</div>

## Pourquoi pas une couche de compatibilit√© ?

Les frameworks JavaScript comme [Preact](https://preactjs.com) et [Inferno](https://infernojs.org) ont des couches de compatibilit√© qui leur permettent de se faire passer pour des composants React mais avec de meilleures performances. Cela a de nombreux avantages, car cela permet aux projets et aux √©quipes d'ing√©nierie de progresser rapidement sans avoir √† r√©√©crire l'int√©gralit√© de leur code.

Mais cela a un co√ªt. Les couches de compatibilit√© doivent toujours rattraper leur retard. Lorsque React ajoute une nouvelle fonctionnalit√©, la couche de compatibilit√© doit la prendre en charge. Maintenir le m√™me comportement est presque impossible, surtout √©muler le m√™me comportement et les avantages du mod√®le de concurrence React.

## Pens√©es finales

En utilisant des m√©thodologies de rendu sp√©cifiques sur une base composant par composant, nous pouvons tirer parti du meilleur des deux mondes et utiliser le bon outil pour le bon travail. Esp√©rons qu'un jour, nous verrons plus de frameworks adopter ce motif. Parce que la performance ne devrait pas √™tre un compromis pour la migration.

[Discuter sur Twitter](https://twitter.com/search?q=https%3A%2F%2Fmillion.dev%2Fblog%2Fbehind-the-block) | [Modifier sur GitHub](https://github.com/aidenybai/million/blob/main/website/pages/blog/behind-the-block.mdx)

## Remerciements

Merci √† [Ryan Carniato](https://twitter.com/ryancarniato) d'avoir cr√©√© un [prototype initial](https://stackblitz.com/edit/hr-meheraj-vite-react-zgzg43?file=src%2FApp.jsx) de Solid.js √† l'int√©rieur de React qui a inspir√© cet article.

Vous en voulez plus ? D√©couvrez une autre [lecture int√©ressante](https://pyjun01.github.io/v/million-js/) de [Yongjun Park](https://github.com/pyjun01).
